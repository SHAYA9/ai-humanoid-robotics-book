"use strict";(globalThis.webpackChunkai_humanoid_robotics_book_new=globalThis.webpackChunkai_humanoid_robotics_book_new||[]).push([[8450],{4128:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"specifyplus/api/rate-limiting","title":"API Rate Limiting","description":"In the context of the SpecifyPlus system and ROS 2, \\"rate limiting\\" and traffic shaping are managed through two primary mechanisms: the publishing rate of nodes and the Quality of Service (QoS) policies.","source":"@site/docs/specifyplus/api/rate-limiting.md","sourceDirName":"specifyplus/api","slug":"/specifyplus/api/rate-limiting","permalink":"/ai-humanoid-robotics-book/docs/specifyplus/api/rate-limiting","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{}}');var r=n(4848),t=n(8453);const a={},o="API Rate Limiting",l={},c=[{value:"Publishing Rate",id:"publishing-rate",level:2},{value:"Quality of Service (QoS) Policies",id:"quality-of-service-qos-policies",level:2},{value:"Reliability",id:"reliability",level:3},{value:"History &amp; Depth",id:"history--depth",level:3},{value:"Durability",id:"durability",level:3},{value:"Lifespan",id:"lifespan",level:3}];function d(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"api-rate-limiting",children:"API Rate Limiting"})}),"\n",(0,r.jsx)(i.p,{children:'In the context of the SpecifyPlus system and ROS 2, "rate limiting" and traffic shaping are managed through two primary mechanisms: the publishing rate of nodes and the Quality of Service (QoS) policies.'}),"\n",(0,r.jsx)(i.h2,{id:"publishing-rate",children:"Publishing Rate"}),"\n",(0,r.jsx)(i.p,{children:"The most straightforward way to limit the rate of data on a topic is to control the frequency at which the publisher node publishes messages."}),"\n",(0,r.jsxs)(i.p,{children:["In an ",(0,r.jsx)(i.code,{children:"rclpy"})," agent, this is typically done using a ",(0,r.jsx)(i.code,{children:"Timer"}),". The timer's period directly controls the publication rate."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Example: A Camera Node Publishing at 10 Hz"})}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import Image\r\n\r\nclass CameraNode(Node):\r\n    def __init__(self):\r\n        super().__init__('camera_node')\r\n        self.publisher_ = self.create_publisher(Image, 'camera/image_raw', 10)\r\n\r\n        # Set a timer to publish at 10 Hz (1 / 0.1s)\r\n        timer_period = 0.1\r\n        self.timer = self.create_timer(timer_period, self.capture_and_publish)\r\n\r\n        # self.camera = ... initialize camera hardware\r\n\r\n    def capture_and_publish(self):\r\n        # image_msg = self.camera.capture() ... get image from hardware\r\n        # self.publisher_.publish(image_msg)\r\n        self.get_logger().info('Publishing image frame')\r\n\r\n# ... main function ...\n"})}),"\n",(0,r.jsxs)(i.p,{children:["By adjusting the ",(0,r.jsx)(i.code,{children:"timer_period"}),', you can effectively "rate limit" the ',(0,r.jsx)(i.code,{children:"/camera/image_raw"})," topic."]}),"\n",(0,r.jsx)(i.h2,{id:"quality-of-service-qos-policies",children:"Quality of Service (QoS) Policies"}),"\n",(0,r.jsx)(i.p,{children:"QoS policies offer a much more sophisticated way to control how data is handled by the underlying DDS communication layer. QoS settings can be configured per-publisher and per-subscriber."}),"\n",(0,r.jsx)(i.p,{children:"Key QoS settings relevant to rate management:"}),"\n",(0,r.jsx)(i.h3,{id:"reliability",children:"Reliability"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"RELIABLE"}),":"]})," Guarantees delivery. If a message is dropped, DDS will try to resend it. This can cause delays if the network is lossy."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"BEST_EFFORT"}),":"]})," Does not guarantee delivery. This is suitable for high-frequency sensor data where it's better to drop a message than to delay a new one."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"history--depth",children:"History & Depth"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"KEEP_LAST"}),":"]})," Only stores up to a certain number of recent messages in the queue."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"DEPTH"}),":"]})," The number of messages to store when using ",(0,r.jsx)(i.code,{children:"KEEP_LAST"}),". If a subscriber is slow, it will only receive the most recent messages up to the depth, and older ones will be dropped. This prevents a slow node from falling behind and being flooded with stale data."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"durability",children:"Durability"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"VOLATILE"}),":"]})," Subscribers will only receive messages that are published after they have connected."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"TRANSIENT_LOCAL"}),":"]})," A publisher will save the last N messages (where N is the history depth) and send them to any new subscribers that connect. This is useful for topics that publish configuration or state that is needed by late-joining nodes."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"lifespan",children:"Lifespan"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsxs)(i.strong,{children:[(0,r.jsx)(i.code,{children:"LIFESPAN"}),":"]})," Sets an expiration time on messages. If a message is not delivered within its lifespan, it is dropped. This is critical for ensuring that control systems do not act on old, irrelevant data."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Example: Setting QoS for a LiDAR Scanner"})}),"\n",(0,r.jsx)(i.p,{children:"A LiDAR scanner produces data at a high rate, and the most recent scan is always the most important."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy\r\n\r\n# Define a QoS profile for a sensor\r\nsensor_qos_profile = QoSProfile(\r\n    reliability=QoSReliabilityPolicy.BEST_EFFORT,\r\n    history=QoSHistoryPolicy.KEEP_LAST,\r\n    depth=1  # Only care about the absolute latest scan\r\n)\r\n\r\n# In the node's __init__ method:\r\nself.subscription = self.create_subscription(\r\n    LaserScan,\r\n    'scan',\r\n    self.listener_callback,\r\n    qos_profile=sensor_qos_profile)\n"})}),"\n",(0,r.jsx)(i.p,{children:"By using these QoS policies, you can fine-tune the data delivery behavior of your SpecifyPlus API endpoints to match the specific requirements of your application, preventing network congestion and ensuring real-time performance."})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var s=n(6540);const r={},t=s.createContext(r);function a(e){const i=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);