"use strict";(globalThis.webpackChunkai_humanoid_robotics_book_new=globalThis.webpackChunkai_humanoid_robotics_book_new||[]).push([[2989],{8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var o=s(6540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}},9562:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"robotics-foundations/the-robot-operating-system-ros-2/core-concepts","title":"7.2 Core Concepts: Nodes, Topics, and Messages","description":"At the heart of ROS 2 is a communication graph where independent programs exchange information. Understanding the three fundamental components of this graph\u2014Nodes, Topics, and Messages\u2014is the key to mastering ROS 2.","source":"@site/docs/01-robotics-foundations/07-the-robot-operating-system-ros-2/02-core-concepts.md","sourceDirName":"01-robotics-foundations/07-the-robot-operating-system-ros-2","slug":"/robotics-foundations/the-robot-operating-system-ros-2/core-concepts","permalink":"/ai-humanoid-robotics-book/docs/robotics-foundations/the-robot-operating-system-ros-2/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/SHAYA9/ai-humanoid-robotics-book/tree/main/docs/01-robotics-foundations/07-the-robot-operating-system-ros-2/02-core-concepts.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"7.1 What is ROS 2?","permalink":"/ai-humanoid-robotics-book/docs/robotics-foundations/the-robot-operating-system-ros-2/what-is-ros-2"},"next":{"title":"7.3 Synchronous Communication: Services and Actions","permalink":"/ai-humanoid-robotics-book/docs/robotics-foundations/the-robot-operating-system-ros-2/synchronous-communication"}}');var t=s(4848),i=s(8453);const r={sidebar_position:2},a="7.2 Core Concepts: Nodes, Topics, and Messages",c={},d=[{value:"The ROS 2 Graph",id:"the-ros-2-graph",level:3},{value:"Creating Your First <code>rclpy</code> Node",id:"creating-your-first-rclpy-node",level:3},{value:"Implementing Publishers and Subscribers",id:"implementing-publishers-and-subscribers",level:3}];function l(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"72-core-concepts-nodes-topics-and-messages",children:"7.2 Core Concepts: Nodes, Topics, and Messages"})}),"\n",(0,t.jsx)(n.p,{children:"At the heart of ROS 2 is a communication graph where independent programs exchange information. Understanding the three fundamental components of this graph\u2014Nodes, Topics, and Messages\u2014is the key to mastering ROS 2."}),"\n",(0,t.jsx)(n.h3,{id:"the-ros-2-graph",children:"The ROS 2 Graph"}),"\n",(0,t.jsxs)(n.p,{children:["Imagine a group of experts in a room. Each expert is a ",(0,t.jsx)(n.strong,{children:"Node"}),". They communicate by writing announcements on a shared whiteboard. Each section of the whiteboard is a ",(0,t.jsx)(n.strong,{children:"Topic"}),". The format of the announcement is the ",(0,t.jsx)(n.strong,{children:"Message"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Nodes:"})," A node is the smallest, most fundamental unit of a ROS 2 system. It's an independent program that performs a specific task. For example, you might have one node for a camera driver, another for image processing, and a third for motor control. Each node is a self-contained executable that can be started, stopped, and restarted independently."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Topics:"})," A topic is a named bus or channel that nodes use to exchange data. Topics are the primary method for asynchronous, many-to-many communication. A node can ",(0,t.jsx)(n.strong,{children:"publish"})," data to a topic, and any number of other nodes can ",(0,t.jsx)(n.strong,{children:"subscribe"})," to that topic to receive the data. For instance, a camera node would publish images to an ",(0,t.jsx)(n.code,{children:"/image_raw"})," topic, and both an image processing node and a display node could subscribe to it."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Messages:"})," When a node publishes data to a topic, it does so using a ",(0,t.jsx)(n.strong,{children:"message"}),". A message is a simple data structure with a defined type. ROS 2 provides many standard message types (e.g., ",(0,t.jsx)(n.code,{children:"String"}),", ",(0,t.jsx)(n.code,{children:"Int32"}),", ",(0,t.jsx)(n.code,{children:"Point"}),") and you can define your own custom messages. For example, the ",(0,t.jsx)(n.code,{children:"/image_raw"})," topic would use the ",(0,t.jsx)(n.code,{children:"sensor_msgs/Image"})," message type, which is a standardized structure for holding image data."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.h3,{id:"creating-your-first-rclpy-node",children:["Creating Your First ",(0,t.jsx)(n.code,{children:"rclpy"})," Node"]}),"\n",(0,t.jsxs)(n.p,{children:["Let's see how this looks in practice. In ROS 2, ",(0,t.jsx)(n.code,{children:"rclpy"}),' is the official Python client library. Here is a minimal "Hello World" node:']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"#\n#\nimport rclpy\nfrom rclpy.node import Node\n\ndef main(args=None):\n    # 1. Initialize the rclpy library\n    rclpy.init(args=args)\n\n    # 2. Create a Node\n    #    The node is named 'my_first_node'\n    node = Node('my_first_node')\n\n    #    (We'll add publishers and subscribers here later)\n    print(\"My first node is alive!\")\n\n    # 3. \"Spin\" the node to keep it running and responsive\n    #    to callbacks (like receiving messages).\n    #    This will block until the node is shut down (e.g., by Ctrl+C).\n    rclpy.spin(node)\n\n    # 4. Cleanly shut down the node and rclpy\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"implementing-publishers-and-subscribers",children:"Implementing Publishers and Subscribers"}),"\n",(0,t.jsx)(n.p,{children:"Now, let's make two nodes that actually communicate."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Publisher Node (",(0,t.jsx)(n.code,{children:"talker.py"}),"):"]})," This node will publish a ",(0,t.jsx)(n.code,{children:"String"})," message to a topic named ",(0,t.jsx)(n.code,{children:"/chatter"})," every second."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass TalkerNode(Node):\n    def __init__(self):\n        super().__init__('talker_node')\n        # Create a publisher\n        # Message type: String\n        # Topic name: /chatter\n        # Queue size: 10 (how many messages to buffer)\n        self.publisher_ = self.create_publisher(String, 'chatter', 10)\n        self.timer_ = self.create_timer(1.0, self.timer_callback)\n        self.counter_ = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f\"Hello World: {self.counter_}\"\n        self.publisher_.publish(msg)\n        self.get_logger().info(f\"Publishing: '{msg.data}'\")\n        self.counter_ += 1\n\n# ... (main function similar to above, but creating a TalkerNode)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Subscriber Node (",(0,t.jsx)(n.code,{children:"listener.py"}),"):"]})," This node subscribes to ",(0,t.jsx)(n.code,{children:"/chatter"})," and prints any message it receives."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass ListenerNode(Node):\n    def __init__(self):\n        super().__init__('listener_node')\n        # Create a subscriber\n        # Message type: String\n        # Topic name: /chatter\n        # Callback function: self.listener_callback\n        # Queue size: 10\n        self.subscription_ = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10)\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f\"I heard: '{msg.data}'\")\n\n# ... (main function similar to above, but creating a ListenerNode)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When you run both of these nodes, you will see the ",(0,t.jsx)(n.code,{children:"talker"})," publishing messages and the ",(0,t.jsx)(n.code,{children:"listener"})," receiving them. This simple, decoupled communication is the foundation of every ROS 2 application."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);