"use strict";(globalThis.webpackChunkai_humanoid_robotics_book_new=globalThis.webpackChunkai_humanoid_robotics_book_new||[]).push([[944],{5492:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"module-1-ros2/ros2-architecture","title":"ROS 2 Architecture","description":"The architecture of ROS 2 is designed to be a flexible, scalable, and robust platform for robotics. It is a significant evolution from ROS 1, built to support a wider range of applications, from small, single-board computers to large, multi-robot systems.","source":"@site/docs/module-1-ros2/ros2-architecture.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/ros2-architecture","permalink":"/ai-humanoid-robotics-book/docs/module-1-ros2/ros2-architecture","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"ROS 2 Architecture"},"sidebar":"tutorialSidebar","previous":{"title":"Module 1: The Robotic Nervous System (ROS 2)","permalink":"/ai-humanoid-robotics-book/docs/module-1-ros2/overview"},"next":{"title":"Nodes, Topics, and Services","permalink":"/ai-humanoid-robotics-book/docs/module-1-ros2/nodes-topics-services"}}');var o=s(4848),t=s(8453);const r={sidebar_position:2,title:"ROS 2 Architecture"},a="ROS 2 Architecture",c={},l=[{value:"The ROS 2 Graph",id:"the-ros-2-graph",level:2},{value:"Nodes: The Building Blocks of a ROS 2 System",id:"nodes-the-building-blocks-of-a-ros-2-system",level:3},{value:"Topics: Asynchronous Communication",id:"topics-asynchronous-communication",level:3},{value:"Services: Synchronous Communication",id:"services-synchronous-communication",level:3},{value:"Actions: Long-Running Tasks",id:"actions-long-running-tasks",level:3},{value:"The Middleware Layer: DDS",id:"the-middleware-layer-dds",level:2},{value:"Security",id:"security",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"ros-2-architecture",children:"ROS 2 Architecture"})}),"\n",(0,o.jsx)(n.p,{children:"The architecture of ROS 2 is designed to be a flexible, scalable, and robust platform for robotics. It is a significant evolution from ROS 1, built to support a wider range of applications, from small, single-board computers to large, multi-robot systems."}),"\n",(0,o.jsx)(n.h2,{id:"the-ros-2-graph",children:"The ROS 2 Graph"}),"\n",(0,o.jsxs)(n.p,{children:["The fundamental concept in ROS 2 is the ",(0,o.jsx)(n.strong,{children:"ROS 2 graph"}),". The graph is a network of ROS 2 nodes that communicate with each other. This distributed, peer-to-peer architecture is one of the key strengths of ROS 2."]}),"\n",(0,o.jsx)(n.h3,{id:"nodes-the-building-blocks-of-a-ros-2-system",children:"Nodes: The Building Blocks of a ROS 2 System"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"node"})," is the main computational unit in ROS 2. Each node is a process that performs a specific task, such as controlling a motor, reading sensor data, or planning a path. In a real-world robotics system, you will typically have many nodes, each responsible for a small, well-defined part of the overall system."]}),"\n",(0,o.jsx)(n.p,{children:"Here is a simple example of a ROS 2 node written in Python:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:'title="my_first_node.py"',children:"import rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n    def __init__(self):\n        super().__init__('my_node')\n        self.get_logger().info('Hello, ROS 2!')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MyNode()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"topics-asynchronous-communication",children:"Topics: Asynchronous Communication"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Topics"})," are the primary mechanism for asynchronous, publish/subscribe communication. A node can publish messages to a topic, and any number of nodes can subscribe to that topic to receive the messages. This is a one-to-many communication pattern that is ideal for streaming data, such as sensor readings or robot state."]}),"\n",(0,o.jsx)(n.p,{children:"Here is an example of a node that publishes a message to a topic:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:'title="publisher_node.py"',children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass PublisherNode(Node):\n    def __init__(self):\n        super().__init__('publisher_node')\n        self.publisher_ = self.create_publisher(String, 'chatter', 10)\n        self.timer = self.create_timer(1.0, self.timer_callback)\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello, world!'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n\n# ... (main function)\n"})}),"\n",(0,o.jsx)(n.p,{children:"And here is an example of a node that subscribes to that topic:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",metastring:'title="subscriber_node.py"',children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass SubscriberNode(Node):\n    def __init__(self):\n        super().__init__('subscriber_node')\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10)\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\n# ... (main function)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"services-synchronous-communication",children:"Services: Synchronous Communication"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Services"})," are used for synchronous, request/response communication. A node can provide a service, and another node can call that service and wait for a response. This is a one-to-one communication pattern that is ideal for remote procedure calls (RPCs)."]}),"\n",(0,o.jsx)(n.h3,{id:"actions-long-running-tasks",children:"Actions: Long-Running Tasks"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Actions"})," are used for long-running, asynchronous tasks that provide feedback. A node can provide an action, and another node can send a goal to that action and receive feedback and a final result. This is ideal for tasks that take a long time to complete, such as navigating to a goal or manipulating an object."]}),"\n",(0,o.jsx)(n.h2,{id:"the-middleware-layer-dds",children:"The Middleware Layer: DDS"}),"\n",(0,o.jsxs)(n.p,{children:["Under the hood, ROS 2 is built on top of the ",(0,o.jsx)(n.strong,{children:"Data Distribution Service (DDS)"}),", an industry-standard middleware for real-time systems. DDS provides a robust and efficient communication layer, with features like:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Discovery:"})," Nodes can automatically discover each other on the network."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Serialization:"})," Messages are automatically serialized and deserialized."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Quality of Service (QoS):"})," ROS 2 provides a rich set of QoS policies that allow you to fine-tune the communication for different use cases, such as reliability, durability, and latency."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"security",children:"Security"}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 has built-in security features that provide a secure communication channel between nodes. This is a critical feature for production robotics systems. The security features include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Authentication:"})," Nodes can verify the identity of other nodes."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Encryption:"})," Messages can be encrypted to prevent eavesdropping."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Access Control:"})," You can define fine-grained access control rules to restrict which nodes can publish or subscribe to which topics."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["In the next section, we will take a closer look at the building blocks of the ROS 2 graph: ",(0,o.jsx)(n.a,{href:"/ai-humanoid-robotics-book/docs/module-1-ros2/nodes-topics-services",children:"Nodes, Topics, and Services"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var i=s(6540);const o={},t=i.createContext(o);function r(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);