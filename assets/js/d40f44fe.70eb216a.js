"use strict";(globalThis.webpackChunkai_humanoid_robotics_book_new=globalThis.webpackChunkai_humanoid_robotics_book_new||[]).push([[8818],{376:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"module-1-ros2/nodes-topics-services","title":"Nodes, Topics, and Services","description":"Now that we have a high-level overview of the ROS 2 architecture, let\'s dive deeper into the core components that make it work: nodes, topics, services, and actions.","source":"@site/docs/module-1-ros2/nodes-topics-services.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/nodes-topics-services","permalink":"/ai-humanoid-robotics-book/docs/module-1-ros2/nodes-topics-services","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Nodes, Topics, and Services"},"sidebar":"tutorialSidebar","previous":{"title":"ROS 2 Architecture","permalink":"/ai-humanoid-robotics-book/docs/module-1-ros2/ros2-architecture"},"next":{"title":"rclpy - Python Agents for ROS 2","permalink":"/ai-humanoid-robotics-book/docs/module-1-ros2/rclpy-python-agents"}}');var t=s(4848),i=s(8453);const r={sidebar_position:3,title:"Nodes, Topics, and Services"},a="Nodes, Topics, and Services",c={},l=[{value:"Nodes",id:"nodes",level:2},{value:"Topics",id:"topics",level:2},{value:"Services",id:"services",level:2},{value:"Actions",id:"actions",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"nodes-topics-and-services",children:"Nodes, Topics, and Services"})}),"\n",(0,t.jsx)(n.p,{children:"Now that we have a high-level overview of the ROS 2 architecture, let's dive deeper into the core components that make it work: nodes, topics, services, and actions."}),"\n",(0,t.jsx)(n.h2,{id:"nodes",children:"Nodes"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"node"})," is the fundamental building block of a ROS 2 system. It is a process that performs a specific, well-defined task. For example, in a humanoid robot, you might have separate nodes for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Controlling the motors in the left leg."}),"\n",(0,t.jsx)(n.li,{children:"Reading data from the IMU sensor."}),"\n",(0,t.jsx)(n.li,{children:"Processing images from the head camera."}),"\n",(0,t.jsx)(n.li,{children:"Planning the robot's path."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Each node can be written in a different programming language (Python and C++ are the most common) and can be run on a different computer, as long as they are on the same network. This distributed nature is a key feature of ROS 2."}),"\n",(0,t.jsx)(n.h2,{id:"topics",children:"Topics"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Topics"})," are the primary mechanism for asynchronous, publish/subscribe communication between nodes. They are named buses that nodes can use to exchange messages."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A node can ",(0,t.jsx)(n.strong,{children:"publish"})," messages to a topic."]}),"\n",(0,t.jsxs)(n.li,{children:["A node can ",(0,t.jsx)(n.strong,{children:"subscribe"})," to a topic to receive messages."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This is a one-to-many or many-to-many communication pattern. For example, the camera node can publish images to an ",(0,t.jsx)(n.code,{children:"/camera/image_raw"})," topic, and multiple nodes (e.g., an object detection node and a logging node) can subscribe to this topic to receive the images."]}),"\n",(0,t.jsx)(n.h2,{id:"services",children:"Services"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Services"})," are used for synchronous, request/response communication. This is a one-to-one communication pattern, where a client node sends a request to a server node and waits for a response."]}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of a service that adds two integers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",metastring:'title="add_two_ints_server.py"',children:"from example_interfaces.srv import AddTwoInts\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request\\na: {request.a} b: {request.b}')\n        return response\n\n# ... (main function)\n"})}),"\n",(0,t.jsx)(n.p,{children:"And here's how you would call that service from another node:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",metastring:'title="add_two_ints_client.py"',children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalClientAsync(Node):\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self):\n        self.req.a = 41\n        self.req.b = 1\n        self.future = self.cli.call_async(self.req)\n\n# ... (main function)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"actions",children:"Actions"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Actions"})," are used for long-running, asynchronous tasks that provide feedback. This is a more complex communication pattern that is ideal for tasks that take a significant amount of time to complete."]}),"\n",(0,t.jsx)(n.p,{children:"An action has three components:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal:"}),' The client sends a goal to the action server (e.g., "walk to the kitchen").']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback:"}),' The action server provides regular feedback to the client on the progress of the goal (e.g., "I have walked 5 meters").']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result:"}),' When the goal is complete, the action server sends a final result to the client (e.g., "I have reached the kitchen").']}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Actions are perfect for tasks like navigation, manipulation, and other complex behaviors. In the next section, we'll learn how to write our own ROS 2 nodes using the ",(0,t.jsx)(n.a,{href:"/ai-humanoid-robotics-book/docs/module-1-ros2/rclpy-python-agents",children:(0,t.jsx)(n.code,{children:"rclpy"})})," library."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var o=s(6540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);