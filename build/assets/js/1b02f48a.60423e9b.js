"use strict";(globalThis.webpackChunkai_humanoid_robotics_book_new=globalThis.webpackChunkai_humanoid_robotics_book_new||[]).push([[8691],{3657:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"robotics-foundations/the-robot-operating-system-ros-2/building-a-ros-2-package","title":"7.6 Building a ROS 2 Package","description":"So far, we\'ve focused on writing and running individual nodes. However, the real power of ROS 2 comes from organizing your code into reusable, shareable units called packages. A package is a directory containing your nodes, launch files, custom message definitions, and a set of files that describe its contents and dependencies.","source":"@site/docs/01-robotics-foundations/07-the-robot-operating-system-ros-2/06-building-a-ros-2-package.md","sourceDirName":"01-robotics-foundations/07-the-robot-operating-system-ros-2","slug":"/robotics-foundations/the-robot-operating-system-ros-2/building-a-ros-2-package","permalink":"/ai-humanoid-robotics-book/docs/robotics-foundations/the-robot-operating-system-ros-2/building-a-ros-2-package","draft":false,"unlisted":false,"editUrl":"https://github.com/SHAYA9/ai-humanoid-robotics-book/tree/main/docs/01-robotics-foundations/07-the-robot-operating-system-ros-2/06-building-a-ros-2-package.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"7.5 Visualization and Debugging","permalink":"/ai-humanoid-robotics-book/docs/robotics-foundations/the-robot-operating-system-ros-2/visualization-and-debugging"},"next":{"title":"7.7 Labs","permalink":"/ai-humanoid-robotics-book/docs/robotics-foundations/the-robot-operating-system-ros-2/labs"}}');var i=s(4848),t=s(8453);const r={sidebar_position:6},a="7.6 Building a ROS 2 Package",c={},d=[{value:"Package Structure",id:"package-structure",level:3},{value:"The <code>colcon</code> Build Process",id:"the-colcon-build-process",level:3}];function l(e){const n={code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"76-building-a-ros-2-package",children:"7.6 Building a ROS 2 Package"})}),"\n",(0,i.jsxs)(n.p,{children:["So far, we've focused on writing and running individual nodes. However, the real power of ROS 2 comes from organizing your code into reusable, shareable units called ",(0,i.jsx)(n.strong,{children:"packages"}),". A package is a directory containing your nodes, launch files, custom message definitions, and a set of files that describe its contents and dependencies."]}),"\n",(0,i.jsxs)(n.p,{children:["The standard tool for building ROS 2 packages is ",(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"colcon"})})," (collective construction). It's a command-line tool that finds all the packages in your workspace, builds them in the correct order, and generates the necessary setup files to make them available to the ROS 2 environment."]}),"\n",(0,i.jsx)(n.h3,{id:"package-structure",children:"Package Structure"}),"\n",(0,i.jsx)(n.p,{children:"A minimal Python-based ROS 2 package has the following structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"my_robot_pkg/\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 setup.cfg\n\u2514\u2500\u2500 my_robot_pkg/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 talker_node.py\n    \u2514\u2500\u2500 listener_node.py\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"package.xml"})}),": This is the manifest file. It contains metadata about the package, such as its name, version, author, and, most importantly, its dependencies on other ROS 2 packages."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-xml",children:'<package format="3">\n  <name>my_robot_pkg</name>\n  <version>0.0.0</version>\n  <description>Example package</description>\n  <maintainer email="user@example.com">Your Name</maintainer>\n  <license>Apache License 2.0</license>\n\n  <depend>rclpy</depend>\n  <depend>std_msgs</depend>\n\n  <test_depend>ament_copyright</test_depend>\n  <test_depend>ament_flake8</test_depend>\n  <test_depend>ament_pep257</test_depend>\n  <test_depend>python3-pytest</test_depend>\n\n  <export>\n    <build_type>ament_python</build_type>\n  </export>\n</package>\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"setup.py"})}),": This is a standard Python ",(0,i.jsx)(n.code,{children:"setuptools"})," script. It tells ",(0,i.jsx)(n.code,{children:"colcon"})," how to build your package and, crucially, defines the ",(0,i.jsx)(n.strong,{children:"entry points"})," that make your nodes executable."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from setuptools import setup\n\npackage_name = 'my_robot_pkg'\n\nsetup(\n    # ... other metadata\n    packages=[package_name],\n    data_files=[\n        # ... data files like launch files\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    entry_points={\n        'console_scripts': [\n            'talker = my_robot_pkg.talker_node:main',\n            'listener = my_robot_pkg.listener_node:main',\n        ],\n    },\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"entry_points"})," dictionary is key. It creates executable scripts (",(0,i.jsx)(n.code,{children:"talker"})," and ",(0,i.jsx)(n.code,{children:"listener"}),") that call the ",(0,i.jsx)(n.code,{children:"main"})," function in your Python node files."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"the-colcon-build-process",children:["The ",(0,i.jsx)(n.code,{children:"colcon"})," Build Process"]}),"\n",(0,i.jsxs)(n.p,{children:["A typical ROS 2 workflow involves a ",(0,i.jsx)(n.strong,{children:"workspace"})," directory that contains all your source packages."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ros2_ws/\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_robot_pkg/\n\u2502       \u251c\u2500\u2500 ... (package files)\n\u251c\u2500\u2500 install/\n\u251c\u2500\u2500 log/\n\u2514\u2500\u2500 build/\n"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Source Code:"})," You place your package source code inside the ",(0,i.jsx)(n.code,{children:"src"})," directory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Build:"})," From the root of the workspace (",(0,i.jsx)(n.code,{children:"ros2_ws"}),"), you run ",(0,i.jsx)(n.code,{children:"colcon build"}),". ",(0,i.jsx)(n.code,{children:"colcon"})," will find all the packages in ",(0,i.jsx)(n.code,{children:"src"}),", resolve their dependencies, and compile them, placing intermediate files in the ",(0,i.jsx)(n.code,{children:"build"})," directory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Install:"})," The final, built executables, libraries, and Python modules are placed in the ",(0,i.jsx)(n.code,{children:"install"})," directory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Source:"})," Before you can use your new package, you must ",(0,i.jsx)(n.strong,{children:"source"})," the workspace's setup file: ",(0,i.jsx)(n.code,{children:"source install/setup.bash"}),". This command updates your environment, adding your package's executables to your ",(0,i.jsx)(n.code,{children:"PATH"})," and making its modules available to Python."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["After sourcing, you can run your nodes using ",(0,i.jsx)(n.code,{children:"ros2 run"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"ros2 run my_robot_pkg talker\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:(0,i.jsxs)("p",{align:"center",children:["PLACEHOLDER: ",(0,i.jsx)(n.code,{children:"colcon"})," Build Process Flowchart"]})}),"\n",(0,i.jsx)(n.em,{children:(0,i.jsxs)("p",{align:"center",children:["A flowchart showing the process: source code in ",(0,i.jsx)(n.code,{children:"src"})," -> ",(0,i.jsx)(n.code,{children:"colcon build"})," -> artifacts in ",(0,i.jsx)(n.code,{children:"build"})," and ",(0,i.jsx)(n.code,{children:"install"})," -> ",(0,i.jsx)(n.code,{children:"source install/setup.bash"})," -> executables available in the environment."]})})]}),"\n",(0,i.jsx)(n.p,{children:"This structured approach is what makes ROS 2 a powerful framework for large-scale robotics development. It ensures that projects are modular, dependencies are managed, and code is easily shareable and reusable."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var o=s(6540);const i={},t=o.createContext(i);function r(e){const n=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);