"use strict";(globalThis.webpackChunkai_humanoid_robotics_book_new=globalThis.webpackChunkai_humanoid_robotics_book_new||[]).push([[8257],{5143:(a,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3-isaac/vslam-navigation","title":"vSLAM Navigation","description":"Visual SLAM (vSLAM) is a technique for Simultaneous Localization and Mapping that uses camera data as its primary input. The Isaac ROS vSLAM package is a powerful, GPU-accelerated implementation that can provide robust and accurate real-time localization and mapping for robots.","source":"@site/docs/module-3-isaac/vslam-navigation.md","sourceDirName":"module-3-isaac","slug":"/module-3-isaac/vslam-navigation","permalink":"/ai-humanoid-robotics-book/docs/module-3-isaac/vslam-navigation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"vSLAM Navigation"},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS","permalink":"/ai-humanoid-robotics-book/docs/module-3-isaac/isaac-ros"},"next":{"title":"Nav2 for Bipedal Robots","permalink":"/ai-humanoid-robotics-book/docs/module-3-isaac/nav2-bipedal"}}');var o=i(4848),n=i(8453);const s={sidebar_position:4,title:"vSLAM Navigation"},r="vSLAM Navigation with Isaac ROS",l={},c=[{value:"How it Works",id:"how-it-works",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Use Cases",id:"use-cases",level:2}];function d(a){const e={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...a.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"vslam-navigation-with-isaac-ros",children:"vSLAM Navigation with Isaac ROS"})}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Visual SLAM (vSLAM)"})," is a technique for Simultaneous Localization and Mapping that uses camera data as its primary input. The Isaac ROS vSLAM package is a powerful, GPU-accelerated implementation that can provide robust and accurate real-time localization and mapping for robots."]}),"\n",(0,o.jsx)(e.h2,{id:"how-it-works",children:"How it Works"}),"\n",(0,o.jsx)(e.p,{children:"The Isaac ROS vSLAM package takes in stereo camera images and IMU data and outputs the robot's pose (position and orientation) and a 3D map of the environment. It's a graph-based SLAM system, which means it builds a graph of keyframes (camera images at specific points in time) and optimizes the relationships between them to produce a globally consistent map."}),"\n",(0,o.jsx)(e.h2,{id:"key-features",children:"Key Features"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"GPU Acceleration:"})," The entire vSLAM pipeline is heavily optimized to run on NVIDIA GPUs, allowing for real-time performance even with high-resolution camera data."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Robustness:"})," The use of stereo vision and IMU data makes the system robust to challenging environments with poor lighting or a lack of distinct visual features."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Integration with Nav2:"})," The output of the Isaac ROS vSLAM package can be directly fed into the ROS 2 Navigation stack (Nav2) for autonomous navigation."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,o.jsx)(e.p,{children:"vSLAM is particularly well-suited for applications where GPS is unavailable or unreliable, such as indoor navigation, and for robots that are equipped with stereo cameras. It's a key enabling technology for a wide range of autonomous mobile robots (AMRs)."})]})}function u(a={}){const{wrapper:e}={...(0,n.R)(),...a.components};return e?(0,o.jsx)(e,{...a,children:(0,o.jsx)(d,{...a})}):d(a)}},8453:(a,e,i)=>{i.d(e,{R:()=>s,x:()=>r});var t=i(6540);const o={},n=t.createContext(o);function s(a){const e=t.useContext(n);return t.useMemo(function(){return"function"==typeof a?a(e):{...e,...a}},[e,a])}function r(a){let e;return e=a.disableParentContext?"function"==typeof a.components?a.components(o):a.components||o:s(a.components),t.createElement(n.Provider,{value:e},a.children)}}}]);