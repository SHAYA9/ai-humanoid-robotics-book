"use strict";(globalThis.webpackChunkai_humanoid_robotics_book_new=globalThis.webpackChunkai_humanoid_robotics_book_new||[]).push([[3452],{5126:(e,s,o)=>{o.r(s),o.d(s,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"autonomous-behaviors-multi-modal-sensors-and-cloud-ops/simulation-environments/sensor-simulation","title":"7.3 Sensor Simulation","description":"One of the most powerful features of Gazebo is its ability to simulate a wide range of robotic sensors. The data generated by these virtual sensors is published to ROS 2 topics, just like data from real hardware. This allows you to test your entire perception and control stack in the simulation without needing a physical robot.","source":"@site/docs/04-autonomous-behaviors-multi-modal-sensors-and-cloud-ops/07-simulation-environments/03-sensor-simulation.md","sourceDirName":"04-autonomous-behaviors-multi-modal-sensors-and-cloud-ops/07-simulation-environments","slug":"/autonomous-behaviors-multi-modal-sensors-and-cloud-ops/simulation-environments/sensor-simulation","permalink":"/ai-humanoid-robotics-book/docs/autonomous-behaviors-multi-modal-sensors-and-cloud-ops/simulation-environments/sensor-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/SHAYA9/ai-humanoid-robotics-book/tree/main/docs/04-autonomous-behaviors-multi-modal-sensors-and-cloud-ops/07-simulation-environments/03-sensor-simulation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"7.2 Physics Simulation Concepts","permalink":"/ai-humanoid-robotics-book/docs/autonomous-behaviors-multi-modal-sensors-and-cloud-ops/simulation-environments/physics-simulation-concepts"},"next":{"title":"7.4 Unity Visualization Plan","permalink":"/ai-humanoid-robotics-book/docs/autonomous-behaviors-multi-modal-sensors-and-cloud-ops/simulation-environments/unity-visualization-plan"}}');var i=o(4848),t=o(8453);const a={sidebar_position:3},r="7.3 Sensor Simulation",l={},d=[{value:"How Sensor Simulation Works",id:"how-sensor-simulation-works",level:3},{value:"Common Sensor Types",id:"common-sensor-types",level:3},{value:"LiDAR (Laser Range Finder)",id:"lidar-laser-range-finder",level:4},{value:"IMU (Inertial Measurement Unit)",id:"imu-inertial-measurement-unit",level:4},{value:"Depth Camera",id:"depth-camera",level:4}];function u(e){const s={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"73-sensor-simulation",children:"7.3 Sensor Simulation"})}),"\n",(0,i.jsx)(s.p,{children:"One of the most powerful features of Gazebo is its ability to simulate a wide range of robotic sensors. The data generated by these virtual sensors is published to ROS 2 topics, just like data from real hardware. This allows you to test your entire perception and control stack in the simulation without needing a physical robot."}),"\n",(0,i.jsx)(s.h3,{id:"how-sensor-simulation-works",children:"How Sensor Simulation Works"}),"\n",(0,i.jsxs)(s.p,{children:["Gazebo simulates sensors using ",(0,i.jsx)(s.strong,{children:"plugins"}),". A plugin is a piece of code that attaches to a robot model and generates sensor data based on the state of the virtual world. For common sensors, you don't need to write code; you can simply add a ",(0,i.jsx)(s.code,{children:"<sensor>"})," tag to your SDF file and configure its properties."]}),"\n",(0,i.jsx)(s.h3,{id:"common-sensor-types",children:"Common Sensor Types"}),"\n",(0,i.jsx)(s.p,{children:"Here\u2019s how Gazebo simulates the most common sensors in robotics:"}),"\n",(0,i.jsx)(s.h4,{id:"lidar-laser-range-finder",children:"LiDAR (Laser Range Finder)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Concept:"})," Gazebo simulates LiDAR by performing GPU-accelerated ",(0,i.jsx)(s.strong,{children:"ray casting"}),". It shoots out thousands of virtual laser beams from the sensor's origin. When a beam hits a collision object in the world, Gazebo calculates the distance and returns it as a data point."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Configuration:"})," You can specify the sensor's update rate, range (min/max distance), field of view, and resolution (number of beams). You can also add a noise model to simulate the imperfections of a real LiDAR."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Output:"})," The plugin publishes ",(0,i.jsx)(s.code,{children:"sensor_msgs/msg/LaserScan"})," messages to a ROS 2 topic."]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"imu-inertial-measurement-unit",children:"IMU (Inertial Measurement Unit)"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Concept:"})," The IMU plugin accesses the physics engine's ground truth state for the link it's attached to. It reads the link's linear acceleration and angular velocity."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Configuration:"})," The most important feature is the ability to add realistic noise. You can configure Gaussian noise and random drift (bias) to the accelerometer and gyroscope readings, which is crucial for testing state estimation and localization algorithms."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Output:"})," The plugin publishes ",(0,i.jsx)(s.code,{children:"sensor_msgs/msg/Imu"})," messages."]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"depth-camera",children:"Depth Camera"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Concept:"})," A depth camera works by rendering the scene from its perspective, but instead of outputting color, it outputs the distance to each pixel. This creates a ",(0,i.jsx)(s.strong,{children:"depth map"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Configuration:"})," You can set the camera's resolution, field of view, and clipping planes (near and far distances). The plugin can also be configured to generate a 3D point cloud directly."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Output:"})," The plugin can publish ",(0,i.jsx)(s.code,{children:"sensor_msgs/msg/Image"})," (for the depth map) or ",(0,i.jsx)(s.code,{children:"sensor_msgs/msg/PointCloud2"})," messages."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"By adding these simulated sensors to your robot's SDF model, you can create a Digital Twin that provides a rich, realistic stream of data for testing your perception, navigation, and control software."})]})}function c(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,s,o)=>{o.d(s,{R:()=>a,x:()=>r});var n=o(6540);const i={},t=n.createContext(i);function a(e){const s=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);